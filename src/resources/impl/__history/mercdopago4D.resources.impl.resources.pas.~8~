unit mercdopago4D.resources.impl.resources;

interface

uses
  mercdopago4D.resources.interfaces,
  mercdopago4D.resources.impl.oauth,
  mercdopago4D.resources.impl.devices, mercdopago4D.resources.impl.payments,
  mercdopago4D.resources.impl.refounds,
  mercdopago4D.resources.impl.conciliation, mercdopago4D.interfaces;

type
  TResources = class(TInterfacedObject, iResources)
  private
    FConf: iConfiguration;

    FOAuth: iOAuth;
    FDevices: iDevices;
    FPayments: iPayments;
    FRefounds: iRefounds;
    FConciliation: iConciliation;

    constructor Create(Conf: iConfiguration);
    destructor Destroy; override;
  public
    class function New(Conf: iConfiguration): iResources;

    function oauth: iOAuth;
    function devices: iDevices;
    function Payments: iPayments;
    function Refounds: iRefounds;
    function Conciliation: iConciliation;
  end;

implementation

function TResources.Conciliation: iConciliation;
begin
  if not Assigned(FConciliation) then
    FConciliation := TConciliation.New;
  Result := FConciliation;
end;

constructor TResources.Create(Conf: iConfiguration);
begin
  FConf:= Conf;
end;

destructor TResources.Destroy;
begin

  inherited;
end;

function TResources.devices: iDevices;
begin
  if not Assigned(FDevices) then
    FDevices := TDevices.New(FConf);
  Result := FDevices
end;

class function TResources.New(Conf: iConfiguration): iResources;
begin
  Result := Self.Create(Conf);
end;

function TResources.oauth: iOAuth;
begin
  if not Assigned(FOAuth) then
    FOAuth := TOAuth.New(FConf);
  Result := FOAuth;
end;

function TResources.Payments: iPayments;
begin
  if not Assigned(FPayments) then
    FPayments := TPayments.New(FConf);
  Result := FPayments;
end;

function TResources.Refounds: iRefounds;
begin
  if not Assigned(FRefounds) then
    FRefounds := TRefounds.New(FConf);
  Result := FRefounds;
end;

end.
